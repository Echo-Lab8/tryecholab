import { useState, useRef, useCallback } from 'react'
import { useLocation } from 'react-router-dom'
import { useVideoHistory } from './hooks/useVideoHistory'
import type { HistoryEntry } from './hooks/useVideoHistory'
import { useStreamPlayback } from './hooks/useStreamPlayback'
import './VideoPage.css'

export default function VideoPage() {
  const location = useLocation()
  const initialPrompt = (location.state as any)?.prompt ?? ''
  const autoGenerate = (location.state as any)?.autoGenerate ?? false

  const [prompt, setPrompt] = useState(initialPrompt)
  const [videoUrl, setVideoUrl] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const [elapsed, setElapsed] = useState(0)
  const timerRef = useRef<number | null>(null)

  const {
    history,
    selectedId,
    setSelectedId,
    addEntry,
    deleteEntry,
    getCachedUrl,
    cacheVideo,
    safeRevoke,
  } = useVideoHistory()

  const selectedIdRef = useRef(selectedId)
  selectedIdRef.current = selectedId

  const handleRecordingComplete = useCallback((url: string) => {
    setVideoUrl(url)
    setIsStreaming(false)
    if (selectedIdRef.current) {
      cacheVideo(selectedIdRef.current, url)
    }
  }, [cacheVideo])

  const {
    isStreaming,
    setIsStreaming,
    streamStatus,
    setStreamStatus,
    isGenerating,
    currentScene,
    canvasRef,
    isPlayingRef,
    startStream,
    stopPlayback,
    resetState,
    fullCleanup,
  } = useStreamPlayback(handleRecordingComplete)

  // ── Auto-generate on mount from Home page ──────────────────

  const hasAutoGenerated = useRef(false)
  if (initialPrompt && autoGenerate && !hasAutoGenerated.current) {
    hasAutoGenerated.current = true
    // Defer to after first render
    setTimeout(() => generate(initialPrompt), 0)
  }

  // ── Core actions ───────────────────────────────────────────

  const generate = async (fromPrompt?: string, addToHistory = true, existingId?: string) => {
    const p = (fromPrompt ?? prompt).trim()
    if (!p) return

    try {
      setLoading(true)
      setIsStreaming(true)
      resetState()

      // Elapsed-time timer
      const start = performance.now()
      setElapsed(0)
      if (timerRef.current) {
        try { window.clearInterval(timerRef.current) } catch (_) {}
      }
      timerRef.current = window.setInterval(() => {
        const tenths = Math.round((performance.now() - start) / 100) / 10
        setElapsed(tenths)
      }, 100)

      // Revoke current video URL if not cached
      if (videoUrl) {
        safeRevoke(videoUrl)
        setVideoUrl(null)
      }

      // Start the pipeline
      startStream(p)
      setStreamStatus('Connecting...')

      // History
      if (addToHistory) {
        addEntry(p)
      } else if (existingId) {
        setSelectedId(existingId)
      }
    } catch (err: any) {
      console.error(err)
      alert('Failed to generate video: ' + (err?.message ?? err))
      fullCleanup()
    } finally {
      setLoading(false)
      if (timerRef.current) {
        try { window.clearInterval(timerRef.current) } catch (_) {}
        timerRef.current = null
      }
    }
  }

  const selectHistory = (entry: HistoryEntry) => {
    setPrompt(entry.prompt)
    const cached = getCachedUrl(entry.id)
    if (cached) {
      fullCleanup()
      safeRevoke(videoUrl)
      setVideoUrl(cached)
      setSelectedId(entry.id)
    } else {
      generate(entry.prompt, false, entry.id)
    }
  }

  const newVideo = () => {
    safeRevoke(videoUrl)
    fullCleanup()
    setVideoUrl(null)
    setPrompt('')
    setSelectedId(null)
  }

  const handleDelete = (id: string) => {
    const wasSelected = deleteEntry(id)
    if (wasSelected) {
      setVideoUrl(null)
      setPrompt('')
      fullCleanup()
    }
  }

  // ── Render ─────────────────────────────────────────────────

  return (
    <div className="video-page">
      {/* ── Sidebar ── */}
      <aside className="video-history">
        <div className="history-header">
          <div className="history-left"><h3>History</h3></div>
          <div className="history-right">
            <button className="btn-primary btn-small" onClick={newVideo}>New</button>
          </div>
        </div>

        <div className="history-list">
          {history.length === 0 && (
            <div className="history-empty">No videos yet — generate one!</div>
          )}
          {history.map((h) => (
            <div
              key={h.id}
              className={`history-item ${selectedId === h.id ? 'selected' : ''}`}
              onClick={() => selectHistory(h)}
              title={h.prompt}
            >
              <div className="history-top">
                <div className="history-prompt">{h.prompt}</div>
                <button
                  className="history-delete"
                  onClick={(e) => { e.stopPropagation(); handleDelete(h.id) }}
                  aria-label="Delete"
                >
                  ✕
                </button>
              </div>
              <div className="history-time">{new Date(h.createdAt).toLocaleString()}</div>
            </div>
          ))}
        </div>
      </aside>

      {/* ── Main ── */}
      <main className="video-main">
        <div className="video-container">
          {isStreaming ? (
            <div className="canvas-wrapper">
              <canvas ref={canvasRef} className="video-player" />

              {isGenerating && (
                <div className="buffer-overlay">
                  <div className="buffer-content">
                    <div className="buffer-spinner" />
                    <div className="buffer-text">Generating Stream</div>
                    {currentScene && (
                      <div className="scene-info">
                        <div className="scene-number">Scene {currentScene.scene_number}</div>
                        <div className="scene-title">{currentScene.title}</div>
                        <div className="scene-description">{currentScene.description}</div>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {streamStatus && !isGenerating && (
                <div className="stream-status-badge">{streamStatus}</div>
              )}

              {isPlayingRef.current && (
                <button onClick={stopPlayback} className="stop-button">Stop</button>
              )}
            </div>
          ) : videoUrl ? (
            <video className="video-player" src={videoUrl} controls autoPlay />
          ) : (
            <div className="video-empty">No video loaded</div>
          )}
        </div>

        <div className="generate-bar">
          <input
            type="text"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault(); generate() } }}
            placeholder="Ask something, e.g. 'Explain quantum entanglement in 20s'"
          />
          <button onClick={() => generate()} disabled={loading} className="btn-primary">
            {loading ? `${elapsed.toFixed(1)}s` : 'Generate'}
          </button>
        </div>
      </main>
    </div>
  )
}
